<style>
code {
   background-color: #efefef;
   font-weight: bold;
}
</style>

CSSS 508, Week 11: Tidy Model Results and Applied Data Cleaning
====================================================================================
author: Charles Lanfear
date: May 30th, 2018
transition: linear
width: 1600
height: 900
font-family: helvetica

```{r setup, include=FALSE}
library(tidyverse)
library(pander)
`%!in%` <- Negate(`%in%`)
```

Topics for Today
====================================================================================

Displaying Model Results

* `broom`
   + Turning model output lists into dataframes
   + Summarizing models
* `ggeffects`
   + Creating predicted values
   + Plotting marginal effects
* Making regression tables
   + Using `pander` for models
   + Using `sjTable()` in `sjPlot`
* Advanced data manipulation example
* Wrapping up the course
  
  

broom
====================================================================================
type: section

broom
====================================================================================

`broom` is a package that "tidies up" the output from models such a `lm()` and `glm()`.

It has a small number of key functions:

* `tidy()` - Creates a dataframe summary of a model.
* `augment()` - Adds columns---such as fitted values---to the data used in the model.
* `glance()` - Provides one row of fit statistics for models.

```{r}
library(broom)
```



Standard Output is Lists
====================================================================================

`lm()` and `summary()` produce lists as output, which cannot go directly into 
tidyverse functions, particularly those in `ggplot2`.

```{r}
data(mtcars)
lm_1 <- lm(mpg~wt+hp, data=mtcars)
summary(lm_1)
```


Standard Output Varies!
====================================================================================
Each type of model also produces somewhat different output, so you can't just reuse
the same code to handle output from every model.

```{r}
glm_1 <- glm(am~hp+wt, data=mtcars, family=binomial(link="logit"))
summary(glm_1)
```

broom tidy()
====================================================================================

`tidy()` produces the same output, but as a dataframe.

```{r}
lm_1 %>% tidy()
```

broom tidy()
====================================================================================

This output is also completely identical between different models. This can be very 
useful and important if running models with different test statistics... or just running
a lot of models!

```{r}
glm_1 %>% tidy()
```


broom glance()
====================================================================================

`glance()` produces dataframes of fit statistics for models. If you run many models,
you can compare each model row-by-row in each column... or even plot their different
fit statistics to allow holistic comparison.

```{r}
glance(lm_1)
```


broom augment()
====================================================================================

`augment()` takes values generated by a model and adds them back to the original data.
This includes fitted values, residuals, and leverage statistics.

```{r}
augment(lm_1) %>% head()
```

The Power of broom
====================================================================================

The real advantage of `broom` becomes apparent when running many models at once:

```{r}
mtcars %>% group_by(cyl) %>% 
  do(tidy(lm(mpg ~  wt + hp + disp, data=.)))
```


ggeffects
====================================================================================
type: section

ggeffects
====================================================================================

While `broom` produces tidy model *summaries*, `ggeffects` is used to create tidy 
*marginal effects*. That is, tidy dataframes of *ranges* of predicted values that can be
fed straight into `ggplot2` for plotting model results.

* `ggpredict()` - Computes predicted values for the outcome variable at margins of specific variables.
* `plot.ggeffects()` - A plot method for `ggeffects` objects (like `ggredict()` output)

```{r}
library(ggeffects)
```

ggpredict()
====================================================================================

When you run  `ggpredict()`, it produces a dataframe with a row for every unique 
value of a supplied predictor ("independent") variable (`term`). Each row contains a 
predicted value for the outcome ("dependent") variable, plus confidence intervals. The argument `interval="prediction"` will give predicted intervals instead.

```{r}
(lm_1_predicted <- ggpredict(lm_1, terms="wt"))
```

plot() for ggpredict()
====================================================================================

`ggeffects` features a `plot()` *method* (`plot.ggeffects()`), which automatically produces
a ggplot when you give `plot()` an object created by a `ggeffects` function.

```{r, fig.width=11, fig.height=6, out.width="1100px", out.height="600px"}
plot(lm_1_predicted)
```


Grouping with ggpredict()
====================================================================================

When using a vector of multiple `terms`, `ggeffects` will plot the first along the x-axis and use
subsequent terms for *grouping*.

```{r, fig.width=11, fig.height=6, out.width="1100px", out.height="600px"}
glm(am ~ hp + wt + cyl, data=mtcars, family=binomial(link="logit")) %>%
  ggpredict(terms=c("wt", "cyl")) %>% plot()
```

Faceting with ggpredict()
====================================================================================

You can add `facet=TRUE` to the `plot()` call to facet over *grouping terms*.

```{r, fig.width=11, fig.height=6, out.width="1100px", out.height="600px"}
glm(am ~ hp + wt + cyl, data=mtcars, family=binomial(link="logit")) %>%
  ggpredict(terms=c("wt", "cyl")) %>% plot(facet=TRUE)
```

Setting Counterfactual Values with ggpredict()
====================================================================================

You can add values in square brackets in the `terms=` argument to specify counterfactual values.

```{r, fig.width=11, fig.height=6, out.width="1100px", out.height="600px"}
glm(am ~ hp + wt + cyl, data=mtcars, family=binomial(link="logit")) %>%
  ggpredict(terms=c("wt [2,3,4]", "cyl [4,6]")) %>% plot(facet=TRUE)
```


Dot plots with ggpredict
====================================================================================

`ggpredict` will produce dot plots with error bars for categorical predictors.

```{r, fig.width=6, fig.height=6, out.width="600px", out.height="600px"}
lm(mpg~as.factor(am)+as.factor(cyl), data=mtcars) %>% ggpredict(terms=c("am", "cyl")) %>% plot()
```

Notes on ggeffects
====================================================================================

There is a lot more to the `ggeffects` package that you can see in [the package vignette](https://cran.r-project.org/web/packages/ggeffects/vignettes/marginaleffects.html)
and the [github repository](https://github.com/strengejacke/ggeffects). This includes,
but is not limited to:

* Setting specific counterfactual values of covariates
* Predicted values for polynomial and interaction terms
* Getting predictions from models from dozens of other packages
* Sending `ggeffects` objects to `ggplot2` to freely modify plots

Making Tables
====================================================================================
type: section

Regression Tables with Pander
====================================================================================

We've used `pander` to create nice tables for dataframes. But `pander` has *methods*
to handle all sort of objects that you might want displayed nicely. This includes 
model output, such as from `lm()`, `glm()`, and `summary()`.


```{r pander}
library(pander)
```

```{r, include=FALSE}
panderOptions("table.style", "rmarkdown")
```

Pander and lm
====================================================================================

You can send an `lm()` object straight to `pander`:

```{r, echo=TRUE, eval=FALSE}
pander(lm_1)
```

| &nbsp;          | Estimate | Std. Error | t value | Pr(>t)    |
|:----------------|:--------:|:----------:|:-------:|:---------:|
| **(Intercept)** |  37.23   |   1.599    |  23.28  | 2.565e-20 |
| **wt**          |  -3.878  |   0.6327   | -6.129  | 1.12e-06  |
| **hp**          | -0.03177 |  0.00903   | -3.519  | 0.001451  |

Table: Fitting linear model: mpg ~ wt + hp

Pander and summary
====================================================================================

You can do this with `summary()` as well, for added information:

```{r, eval=FALSE, echo=TRUE}
pander(summary(lm_1))
```

| &nbsp;          | Estimate | Std. Error | t value | Pr(>t)  |
|:----------------|:--------:|:----------:|:-------:|:---------:|
| **(Intercept)** |  37.23   |   1.599    |  23.28  | 2.565e-20 |
| **wt**          |  -3.878  |   0.6327   | -6.129  | 1.12e-06  |
| **hp**          | -0.03177 |  0.00903   | -3.519  | 0.001451  |



| Observations | Residual Std. Error | $R^2$  | Adjusted $R^2$ |
|:------------:|:-------------------:|:------:|:--------------:|
|      32      |        2.593        | 0.8268 |     0.8148     |

Table: Fitting linear model: mpg ~ wt + hp

sjPlot
====================================================================================

`pander` tables are great for `rmarkdown` documents or webpages, but they're not 
generally publication ready. The `sjPlot` package produces tables that look more like
those you may find in journal articles.

```{r table_packages}
library(sjPlot)
```

sjPlot Tables
====================================================================================

`sjt.lm()` will produce attractive plots for `lm()` objects. `sjt.glm()` handles `glm()` models.

```{r, eval=FALSE}
model_1 <- lm(mpg ~ wt, data = mtcars)
sjt.lm(model_1)
```

```{r, echo=FALSE, out.width = "600px"}
# If you're seeing this, you are looking in my presentation files.
# I actually have to call on a saved image here because sjPlot
# doesn't display properly in .Rpres slides for some reason.
knitr::include_graphics("img/sjPlot_table.PNG")
```

Multi-Model Tables with sjTable
====================================================================================

Often in journal articles you will see a single table that compares multiple models.
Typically, authors will start with a simple model on the left, then add variables, 
until they have their most complex model on the right. The `sjPlot` package makes 
this easy to do: just give it more models!


sjTable with Multiple Models
====================================================================================

```{r, eval=FALSE}
model_2 <- lm(mpg ~ hp + wt, data = mtcars)
model_3 <- lm(mpg ~ hp + wt + factor(am), data = mtcars)
sjt.lm(model_1, model_2, model_3)
```

```{r, echo=FALSE, out.width = "1280px"}
# If you're seeing this, you are looking in my presentation files.
# I actually have to call on a saved image here because sjPlot
# doesn't display properly in .Rpres slides for some reason.
knitr::include_graphics("img/sjPlot_mtable.PNG")
```


sjPlot does a lot more
====================================================================================

The sjPlot package does *a lot* more than just make pretty tables. It is a rabbit hole
of *incredibly* powerful and useful functions for displaying descriptive and inferential results.

View the [package website](http://www.strengejacke.de/sjPlot/) for extensive documentation.

`sjPlot` is a bit more complicated than `ggeffects` but can do just about everything 
it can do; they were written by the same author!

`sjPlot` is fairly new but may be poised to be a comprehensive solution for `ggplot`
based publication-ready social science data visualization. All graphical functions in
`sjPlot` are based on `ggplot2`, so it should not take terribly long to figure out.

sjPlot Example: Likert scale plots
====================================================================================

![](img/sjPlot_likert.PNG)


sjPlot Example: Crosstabs
====================================================================================

![](img/sjPlot_crosstab.PNG)

LaTeX Tables in Theses / Dissertations / Posters
====================================================================================

For tables in $\LaTeX$ documents, which are common for theses, dissertations, and posters,
I recommend either manually generating tables or looking into the `kableExtra` package.

`kableExtra` allows the construction of complex tables in either HTML or $\LaTeX$ using
additive syntax similar to `ggplot2`.

In the past, most R users used `xtable` and `stargazer` to generate $\LaTeX$ tables, 
but these are date or idosyncratic. They definitely work, however!

If you want to edit $\LaTeX$ documents, you can do it in R using Sweave documents (.Rnw).
Alternatively, you may want to work in a dedicated LaTeX editor; I recommend [Overleaf](http://www.overleaf.com)
for this purpose.

RMarkdown has support for a fair amount of basic LaTeX syntax if you aren't trying to 
get too fancy.

One approach I have used is to manually format $\LaTeX$ tables but use in-line R calls to 
fill in the values dynamically. This gets you the exact format you want but without 
forcing you to update values any time something changes.


Bonus: corrplot
====================================================================================

The `corrplot` package has functions for displaying correlograms.

These make visualizing the correlations between variables in a data set easier.

The first argument is a call to `cor()` the base R function for generating a correlation matrix.

[See the vignette for customization options.](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html)

```{r, message=FALSE, warning=FALSE, eval=FALSE}
library(corrplot)
corrplot(
  cor(mtcars),
  addCoef.col = "white",
  addCoefasPercent=T,
  type="upper", 
  order="AOE")
```



***

## Correlogram

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
library(corrplot)
corrplot(cor(mtcars), addCoef.col = "white", addCoefasPercent=T, type="upper", order="FPC")
```



Advanced Data Manipulation
====================================================================================
type: section

This section walks you through an example of a real-world data management scenario.

We will use a small extract from the **Denver Youth Survey**, a 10-wave (in this example) panel data set with 1526 respondents.


Example Data
====================================================================================

```{r}
load("mar_ages.RData") # Tiny sample of my real data
mar_ages
```

Structure of the Data
====================================================================================

These data are in "long" format where each individual has multiple observations.
Our "time" is in *age* rather than years and our observations are *person-marriages*.

Variables:

* **seqid** - Individual identifier
* **byr** - Birth year
* **marriage_n** - Marriage number (most never married or once)
* **marriage_age** - If married, the age at which they married
* **divorce_age** - If divorced, the age at which they divorced
* **censored_age** - Last age they were observed in data

The Goal
====================================================================================

The goal is to get a dataframe that looks like this:

* Each *row* corresponds to a *person*
* Each *column* corresponds to an *age*, from 10 to 27.
* Each cell value is...
   + Married = 1
   + Not Married = 0
   + Unknown/Missing = NA

How are we going to do this?

Some Comments
====================================================================================

I like to type out long comments that describe my problem and possible strategies!

![](img/comment_cap.PNG)

If interested, [here is a link to my *unedited script* this is all taken from.](https://raw.githubusercontent.com/clanfear/CSSS508/master/Lectures/Week11/marriage_dates_to_age_year_110317.R)
It is a bit messy, long, and inefficient but is a realistic example of "in-use" code. Note that it assumes access to the full data set, which I cannot share.

Strategy
====================================================================================

There are many ways to approach this problem, but this was the strategy I came up with:

1. Get the ages in which individuals were known to be married.
   * If married once and never divorced, this is all ages from `marriage_age` to `censored_age`
   * If divorced, it is from `marriage_age` to `divorce_age`.
   * Multiple marriages are just more of the above.
2. Get the ages in which individuals were known to be not married.
   * If never married, they were not married up until `censored_age`.
   * If married and divorced, they were not married until `marriage_age` and after `divorce_age`, until another marriage.
3. What remains is the unknown or missing ages.
4. Make a matrix of individuals (rows) and ages (columns) and populate the cells using 1, 2, and 3.



Coding Married Ages 1
====================================================================================

First, get a **list** where each **element** is a **vector** of married ages for *each marriage*.

```{r, eval=TRUE}
married_years <- vector("list", nrow(mar_ages))
names(married_years) <- paste0(mar_ages$seqid, "-", mar_ages$marriage_n)
for (i in 1:nrow(mar_ages)){
  if (is.na(mar_ages$marriage_age[i])){
    married_years[[i]] <- NA # Assign NA if no marriage
  } else if (!is.na(mar_ages$marriage_age[i]) & # Was married...
              is.na(mar_ages$divorce_age[i])) { # but not divorced
      if (mar_ages$marriage_age[i] <= mar_ages$censored_age[i]){
         married_years[[i]] <- # Marriage age to censored age
           mar_ages$marriage_age[i]:mar_ages$censored_age[i]
      } else { # If married for only one year
         married_years[[i]] <- mar_ages$marriage_age[i]
      }
  } else if (!is.na(mar_ages$marriage_age[i]) & # Married...
             !is.na(mar_ages$divorce_age[i])) { # ... and divorced
    married_years[[i]] <- # Marriage age to divorce age
      mar_ages$marriage_age[i]:mar_ages$divorce_age[i]
  } else { # Print ERROR if none of above conditions apply
    married_years[[i]] <- "ERROR"; print(paste0("Error on ", i))
  }}
```

Coding Married Ages 2
====================================================================================

```{r, eval=TRUE}
head(married_years)
```

Coding Married Ages 3
====================================================================================

Next, *combine* each person's *three vectors* into *one vector* of married ages.

```{r, eval=TRUE}
age_year_yes_list <- vector("list", length(unique(mar_ages$seqid)))
names(age_year_yes_list) <- paste0("seqid_", unique(mar_ages$seqid))
for (i in 1:length(age_year_yes_list)){
  vals <- c(married_years[[(3*i)-2]],
            married_years[[(3*i)-1]], 
            married_years[[(3*i)]])
  if (all(is.na(vals))) {
    age_year_yes_list[[i]] <- NA # NA if all values are NA
  } else { # Otherwise, assign non-NA values
  age_year_yes_list[[i]] <- unique(vals[!is.na(vals)])
  }
}
```

Coding Married Ages 4
====================================================================================

```{r, eval=TRUE}
head(age_year_yes_list)
```


Coding Unmarried Ages 1
====================================================================================

Similar to the married code, but now I assume no one was married at age 10 and work from there up.

```{r, eval=TRUE}
unmarried_years <- vector("list", nrow(mar_ages))
names(unmarried_years) <- paste0(mar_ages$seqid, "-", mar_ages$marriage_n)
for (i in 1:nrow(mar_ages)){
  if (is.na(mar_ages$censored_age[i])) {
    unmarried_years[[i]] <- NA # NA if always censored
  } else if (is.na(mar_ages$marriage_age[i])) { # If never married
    unmarried_years[[i]] <- 10:mar_ages$censored_age[i]
  } else if (!is.na(mar_ages$marriage_age[i]) & # Married...
              is.na(mar_ages$divorce_age[i])){ # ... without divorce
    unmarried_years[[i]] <- 10:mar_ages$marriage_age[i]
  } else if (!is.na(mar_ages$marriage_age[i]) & # Married...
             !is.na(mar_ages$divorce_age[i])) { # ... and divorced
    unmarried_years[[i]] <- c(10:mar_ages$marriage_age[i],
            mar_ages$divorce_age[i]:mar_ages$censored_age[i])
  } else {
    unmarried_years[[i]] <- "ERROR"; print(paste0("Error on ", i))
  }
}
```

Coding Unarried Ages 2
====================================================================================

```{r, eval=TRUE}
head(unmarried_years)
```


Coding Unmarried Ages 3
====================================================================================

Combine all unmarried ages into a single vector per person.

```{r, eval=TRUE}
age_year_no_list <- vector("list", length(unique(mar_ages$seqid)))
names(age_year_no_list) <- paste0("seqid_", unique(mar_ages$seqid))
for (i in 1:length(age_year_no_list)){
  vals <- c(unmarried_years[[(3*i)-2]],
            unmarried_years[[(3*i)-1]],
            unmarried_years[[(3*i)]])
  if (all(is.na(vals))) {
    age_year_no_list[[i]] <- NA
  } else {
    age_year_no_list[[i]] <- unique(vals[!is.na(vals)])
    age_year_no_list[[i]] <- 
      age_year_no_list[[i]][age_year_no_list[[i]] %!in%
                              age_year_yes_list[[i]]]
  }
}
```

Coding Unmarried Ages 4
====================================================================================

```{r, eval=TRUE}
head(age_year_no_list)
```


A Function to Convert from Lists to a Matrix
====================================================================================

```{r, eval=TRUE}
ay_list_to_ay_mat <- function(age_year_yes_list, age_year_no_list){
  age_year_mat <- setNames(as.data.frame(matrix(as.numeric(NA), 
              ncol=length(10:27), nrow=6)), paste0("age_", 10:27))
  for(i in 1:6){ # Six individuals!
    if (any(!is.na(age_year_yes_list[[i]]))){
      age_year_mat[i, age_year_yes_list[[i]]-9 ] <- 1
    } # Above: If any married ages, assign 1 to corresponding cells
    if (any(!is.na(age_year_no_list[[i]]))){
      age_year_mat[i, age_year_no_list[[i]]-9 ] <- 0
    } # Above: If any unmarried ages, assign 1 to corresponding cells
  }
  return(age_year_mat)
}

mar_age_year_mat <- 
  ay_list_to_ay_mat(age_year_yes_list = age_year_yes_list,
                    age_year_no_list = age_year_no_list)
mar_age_year_mat <- mar_age_year_mat %>% 
  mutate(seqid=c(1,2,10,18,280,417)) %>% 
  select(seqid, starts_with("age"), -age_27)
```

What Did We get?
====================================================================================
```{r, eval=TRUE}
mar_age_year_mat %>% select(seqid, age_10:age_17)
mar_age_year_mat %>% select(seqid, age_18:age_25)
```

Conclusion
====================================================================================

Data wrangling can be very complicated, with many valid ways of accomplishing it.

I believe the best general approach is the following:

1. Look carefully at the **starting data** to figure out what you can get from them.
2. Determine *precisely* what you want the **end product** to look like.
3. Identify individual steps needed to go from Step 1 to Step 2.
4. Make each discrete step its own set of functions or function calls.
   + If any step is confusing or complicated, **break it into more steps**.
5. Complete each step *separately and in order*.
   + Do not continue until a step is producing what you need for the next step.
   + **Do not worry about combining steps for efficiency until everything works**.
   
Once finished, if you need to do this again, *convert the prior steps into functions*!

Wrapping up the Course
====================================================================================
type: section


What You've Learned
====================================================================================

A lot!

* How to get data into R from a variety of formats
* How to do "data custodian" work to manipulate and clean data
* How to make pretty visualizations
* How to automate with loops and functions
* How to combine text, calculations, plots, and tables into dynamic R Markdown reports 
* How to acquire and work with spatial data


What Comes Next?
====================================================================================

* Statistical inference (e.g. more CSSS courses)
    + Functions for hypothesis testing, hierarchical/mixed effect models, machine learning, survey design, etc. are straightforward to use... once data are clean
    + Access output by working with list structures (like from regression models) or using `broom` and `ggeffects`
* Practice, practice, practice!
    + Replicate analyses you've done in Excel, SPSS, or Stata
    + Think about data using `dplyr` verbs, tidy data principles
    + R Markdown for documenting cleaning and analysis start-to-finish
* More advanced projects
    + Using version control (git) in RStudio
    + Interactive Shiny web apps
    + Write your own functions and put them in a package
    

Course Plugs
====================================================================================

If you...

* have no stats background yet - **SOC504: Applied Social Statistics**
* liked last week - **SOC590: Big Data and Population Processes**
* have (only) finished SOC506 - **CSSS510: Maximum Likelihood**
* want to master visualization - **CSSS569: Visualizing Data**
* study events or durations - **CSSS544: Event History Analysis**
* want to use network data - **CSSS567: Social Network Analysis**
* want to work with spatial data - **CSSS554: Spatial Statistics**

Thank you!
====================================================================================
type: section